Это вторая статья из цикла статей о powerpreterе. Это вторая статья из цикла статей о powerpreterе. Первую вы можете прочитать здесь: http://www.securitylab.ru/analytics/448980.php Мы можем использовать Powerpreter, чтобы получить удаленный доступ и взламывать другие машины в сети. Далее я предполагаю, что у нас есть права локального администратора к машине в какой-то сети. Также наша учетная запись имеет права на доступ к другим машинам в сети (как и в большинстве корпоративных сетей). Удаленный доступ Powerpreter содержит функционал Pivot. Он основывается на Powershell Remoting, то есть все, что можно сделать через Pivot, можно сделать и с помощью Invoke-Command. По сути Pivot просто является оболочкой для Invoke-Command. Он может быть использован как в интерактивном, так и в не интерактивном режиме. Можно использовать имя пользователя и пароль или авторизацию текущей сессии (например, используя WCE-сгенерированную powershell сессию). Давайте рассмотрим процедуру получения удаленного контроля (Pivot) над одной машиной. . Мы можем проделать это и для нескольких машин. Давайте посмотрим результат не интерактивного Pivotа на нескольких машинах. Просто и удобно, не правда ли? Не интерактивный режим, конечно хорош, но он не сравнится с интерактивным. Давайте посмотрим, как происходит интерактивное получение доступа с помощью WCE-сгенерированного powershell (с использованием хэша пароля). Отлично! У нас тут две сессии. Можем использовать Get-PSSession cmdlet для их отображения. Для взаимодействия с сессией используем функцию powerpreterа Use-Session Для взаимодействия мы можем использовать встроенную cmdlet Enter-PSSession. Возникает вопрос, зачем мы используем разные функции для выполнения похожих действий? Это случается, когда имеет место попытка вызова Enter-PSSession из удаленной сессии powerpreterа . Что следует помнить в предыдущем примере: При использовании Pivot с удаленной машины, следует использовать учетные данные в форме имя_компьютераимя_пользователя При попытке вызова Enter-PSSession из удаленной сессии, была получена ошибка, AFAIK не поддерживается. Но Use-Session работает! Почему же Use-Session работает? function Use-Session { <# .ОБЗОР Функция, которую можно использовать, для взаимодействия с удаленной сессией, созданной с помощью Pivot. .ОПИСАНИЕ Данный функционал позволяет взаимодействовать с сессией, созданной с помощью Pivot. Для получения списка созданных Pivot сессий используйте Get-PSSSession. .ПАРАМЕТР id ID сессии, с которой необходимо взаимодействовать. .ПРИМЕР PS > Use-Session -id <id> Данная команда для подключения к целевому компьютеру использует учетные данные, доступные в текущей Powershell сессии. Она создает PSSsessions. Для взаимодействия с созданной сессией спользуйте Use-Session. .LINK http://code.google.com/p/nishang #> Param ( [Parameter(Position = 0, Mandatory = $True)] $id) while($cmd -ne "exit") { $sess = Get-PSSession -Id $id $computername = $sess.ComputerName write-host -NoNewline "$computername> " $cmd = read-host $sb = [scriptblock]::Create($cmd) Invoke-Command -ScriptBlock $sb -Session $sess } } Вызов Invoke-Command поддерживается из удаленной powershell сессии. Мы используем ее с ключом Session, чтобы сохранить ее состояние и иметь возможность использовать ее интерактивно. Теперь давайте рассмотрим еще некоторый функционал powerpreterа, позволяющий взламывать компьютеры, находящиеся с вами в одной сети. Port-Scan Как следует из названия, мы можем использовать данную функцию для сканирования портов на других компьютерах сети. Стоит отметить, что для сканирования портов был использован ключ ScanPort. По умолчанию выполняется только ping, а также существует набор портов, сканируемых данной командой, но можно задать и свой набор портов. Давайте поищем MS SQL Server в нашей сети. Бинго! Мы нашли один. Brute-Force Данная функция позволяет осуществлять взлом перебором значений таких служб, как, MSSQL, ActiveDirectory, Web или FTP на других компьютерах (по умолчанию MSSQL). Давайте взломаем ранее найденный MSSQL Server с именем пользователя sa. Подобрали пароль! Как вы видите, мы можем использовать словарь паролей (а также IP адресов и имен пользователей) вместо использования одного пароля. Здесь есть небольшая уловка: список паролей должен начинаться со слова password, как в нашем примере. Почему? Давайте взглянем на код. Param( [Parameter(Mandatory = $true, Position = 0, ValueFromPipeLineByPropertyName = $true)] [Alias("PSComputerName","CN","MachineName"," IP","IPAddress","ComputerName","Url","Ftp" ,"Domain","DistinguishedName")] [string]$Identity, [parameter(Position = 1, ValueFromPipeLineByPropertyName = $true)] [string]$UserName, [parameter(Position = 2, ValueFromPipeLineByPropertyName = $true)] [string]$Password, [parameter(Position = 3)] [ValidateSet("SQL","FTP","ActiveDirectory","Web")] [string]$Service = "SQL" ) Все из-за свойства ValueFromPipeLineByPropertyName. Для более детального ознакомления см.http://blogs.msdn.com/b/powershell/archive/2009/01/05/revisiting-old-posts-get-process-dir-about-valuefrompipelinebypropertyname.aspx Execute-Command-MSSQL Что ж, у нас есть учетные данные для MSSQL Server, что дальше? Для того чтобы понять работу Execute-Command-MSSQL, см. предыдущую статью цикла: http://www.labofapenetrationtester.com/2012/12/command-execution-on-ms-sql-server-using-powershell.html Create-Multiple-Session Функция, которая может проверить учетные данные на удаленной машине, а также открыть PSSessions, если они являются актуальными. Для более детального ознакомления см. http://www.labofapenetrationtester.com/2013/04/poshing-the-hashes.html В powerpreter и другие скрипты, используемые в рамках Nishang, внесены некоторые изменения. Поэтому я выпустил новую версию Nishang 0.3.1. Репозиторий здесь: http://code.google.com/p/nishang/ Как всегда делитесь впечатлениями, сообщайте, если найдете ошибки и оставляйте пожелания.